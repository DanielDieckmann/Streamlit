# -*- coding: utf-8 -*-
"""fetch_covers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rFFeQDjgHtLeifm2xOgo_QdfYDEn_Zr9
"""

import streamlit as st
import numpy as np
import pandas as pd

# Load the datasets
interactions = pd.read_csv('https://raw.githubusercontent.com/olivialaven/MGT502_project/refs/heads/main/interactions_train.csv')
items = pd.read_csv("https://raw.githubusercontent.com/olivialaven/MGT502_project/refs/heads/main/items.csv")
recommendations = pd.read_csv("https://raw.githubusercontent.com/DanielDieckmann/Streamlit/refs/heads/main/top_recs.csv")

target_user_id = 5848

def get_recommendations_as_list(df, user_id, id_col='user_id', rec_col='recommendations'):
    """
    Returns a list of recommendations (split by space) for the given user_id.
    """
    result = df.loc[df[id_col] == user_id, rec_col]
    if not result.empty:
        return result.values[0].split()
    else:
        return []
top_ten_user = get_recommendations_as_list(recommendations, target_user_id)
top_ten_user

def get_isbn_dict_by_book_ids(book_id_list, books_df, book_id_col='i', isbn_col='ISBN Valid'):
    """
    Returns a dictionary mapping each book ID (as str) to a list of its ISBNs.
    Handles mixed types by converting book IDs to strings.
    """
    # Convert both list and column to string for consistent matching
    book_id_list = list(map(str, book_id_list))
    books_df = books_df.copy()
    books_df[book_id_col] = books_df[book_id_col].astype(str)

    # Filter for matching book IDs
    matched_df = books_df[books_df[book_id_col].isin(book_id_list)][[book_id_col, isbn_col]]

    # Split ISBNs into lists
    matched_df[isbn_col] = matched_df[isbn_col].astype(str).str.split()

    # Group into dictionary
    isbn_dict = matched_df.set_index(book_id_col)[isbn_col].to_dict()

    return isbn_dict

isbn_dict = get_isbn_dict_by_book_ids(top_ten_user, items)
isbn_dict

isbn_dict = get_isbn_dict_by_book_ids(top_ten_user, items)
print(isbn_dict)

import requests

def get_book_covers_by_isbn_dict(isbn_dict):
    """
    For each book_id, try its list of ISBNs with Google Books API.
    Returns a dict {book_id: cover_image_url}, or None if no cover found.
    """
    cover_dict = {}

    for book_id, isbn_list in isbn_dict.items():
        cover_url = None

        for isbn in isbn_list:
            try:
                response = requests.get(f'https://www.googleapis.com/books/v1/volumes?q=isbn:{isbn}')
                data = response.json()

                if 'items' in data:
                    volume_info = data['items'][0]['volumeInfo']
                    image_links = volume_info.get('imageLinks', {})
                    cover_url = image_links.get('thumbnail')  # or 'smallThumbnail'

                    if cover_url:
                        break  # Stop at the first valid cover

            except Exception as e:
                print(f"Error fetching ISBN {isbn} for book_id {book_id}: {e}")
                continue

        cover_dict[book_id] = cover_url  # Will be None if no cover was found

    return cover_dict

cover_urls = get_book_covers_by_isbn_dict(isbn_dict)
cover_urls

import matplotlib.pyplot as plt
import requests
from PIL import Image
from io import BytesIO

import streamlit as st
import matplotlib.pyplot as plt
import requests
from PIL import Image
from io import BytesIO

def show_book_covers_from_dict(cover_dict):
    """
    Displays book covers using a dictionary {book_id: cover_url}.
    If the cover_url is None, shows a placeholder.
    """
    # üîê Safety check
    if not cover_dict:
        st.warning("No book covers found.")
        return

    book_ids = list(cover_dict.keys())
    num_books = len(book_ids)

    fig, axes = plt.subplots(1, num_books, figsize=(2.5 * num_books, 5))

    # If only 1 book, axes is not a list, so wrap it
    if num_books == 1:
        axes = [axes]

    for i, book_id in enumerate(book_ids):
        ax = axes[i]
        cover_url = cover_dict[book_id]

        if cover_url:
            try:
                response = requests.get(cover_url)
                img = Image.open(BytesIO(response.content))
                ax.imshow(img)
            except Exception as e:
                st.write(f"Error loading cover for book {book_id}: {e}")
                _show_placeholder(ax)
        else:
            _show_placeholder(ax)

        ax.axis('off')

    plt.tight_layout()
    st.pyplot(fig)

def _show_placeholder(ax):
    """Draw a 'Cover Not Available' placeholder."""
    ax.text(0.5, 0.5, "Cover Not\nAvailable", ha='center', va='center', fontsize=10, wrap=True)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_facecolor('lightgray')

# Ensure `cover_urls` exists and is valid
if 'cover_urls' in globals() and cover_urls:
    show_book_covers_from_dict(cover_urls)
else:
    st.warning("No cover URLs to show.")


def _show_placeholder(ax):
    """Draw a 'Cover Not Available' placeholder."""
    ax.text(0.5, 0.5, "Cover Not\nAvailable", ha='center', va='center', fontsize=10, wrap=True)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_facecolor('lightgray')

show_book_covers_from_dict(cover_urls)

st.title("Input-Based Code Execution")

# Step 1: Get input from user
target_user_id = st.text_input("Enter a user ID:")

# Step 2: Button to trigger processing
if st.button("Run Code"):
    st.write("Running your code with this input:", target_user_id)

    # Replace with your actual logic
    top_ten_user = get_recommendations_as_list(recommendations, target_user_id)
    isbn_dict = get_isbn_dict_by_book_ids(top_ten_user, items)
    cover_urls = get_book_covers_by_isbn_dict(isbn_dict)
    show_book_covers_from_dict(cover_urls)

    st.write("Code execution completed.")
